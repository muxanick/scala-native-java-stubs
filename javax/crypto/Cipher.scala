package javax.crypto

import java.lang.{Object, String}
import java.nio.ByteBuffer
import java.security.{AlgorithmParameters, Key, Provider, SecureRandom}
import java.security.cert.Certificate
import java.security.spec.AlgorithmParameterSpec

/** This class provides the functionality of a cryptographic cipher for
 *  encryption and decryption. It forms the core of the Java Cryptographic
 *  Extension (JCE) framework.
 * 
 *  In order to create a Cipher object, the application calls the
 *  Cipher's getInstance method, and passes the name of the
 *  requested transformation to it. Optionally, the name of a provider
 *  may be specified.
 * 
 *  A transformation is a string that describes the operation (or
 *  set of operations) to be performed on the given input, to produce some
 *  output. A transformation always includes the name of a cryptographic
 *  algorithm (e.g., AES), and may be followed by a feedback mode and
 *  padding scheme.
 * 
 *   A transformation is of the form:
 * 
 *  
 *  "algorithm/mode/padding" or
 * 
 *  "algorithm"
 *  
 * 
 *   (in the latter case,
 *  provider-specific default values for the mode and padding scheme are used).
 *  For example, the following is a valid transformation:
 * 
 *  
 *      Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
 *  
 * 
 *  Using modes such as CFB and OFB, block
 *  ciphers can encrypt data in units smaller than the cipher's actual
 *  block size.  When requesting such a mode, you may optionally specify
 *  the number of bits to be processed at a time by appending this number
 *  to the mode name as shown in the "AES/CFB8/NoPadding" and
 *  "AES/OFB32/PKCS5Padding" transformations. If no such
 *  number is specified, a provider-specific default is used.
 *  Thus, block ciphers can be turned into byte-oriented stream ciphers by
 *  using an 8 bit mode such as CFB8 or OFB8.
 *  
 *  Modes such as Authenticated Encryption with Associated Data (AEAD)
 *  provide authenticity assurances for both confidential data and
 *  Additional Associated Data (AAD) that is not encrypted.  (Please see
 *   RFC 5116  for more
 *  information on AEAD and AEAD algorithms such as GCM/CCM.) Both
 *  confidential and AAD data can be used when calculating the
 *  authentication tag (similar to a Mac).  This tag is appended
 *  to the ciphertext during encryption, and is verified on decryption.
 *  
 *  AEAD modes such as GCM/CCM perform all AAD authenticity calculations
 *  before starting the ciphertext authenticity calculations.  To avoid
 *  implementations having to internally buffer ciphertext, all AAD data
 *  must be supplied to GCM/CCM implementations (via the updateAAD
 *  methods) before the ciphertext is processed (via
 *  the update and doFinal methods).
 *  
 *  Note that GCM mode has a uniqueness requirement on IVs used in
 *  encryption with a given key. When IVs are repeated for GCM
 *  encryption, such usages are subject to forgery attacks. Thus, after
 *  each encryption operation using GCM mode, callers should re-initialize
 *  the cipher objects with GCM parameters which has a different IV value.
 *  
 *      GCMParameterSpec s = ...;
 *      cipher.init(..., s);
 * 
 *      // If the GCM parameters were generated by the provider, it can
 *      // be retrieved by:
 *      // cipher.getParameters().getParameterSpec(GCMParameterSpec.class);
 * 
 *      cipher.updateAAD(...);  // AAD
 *      cipher.update(...);     // Multi-part update
 *      cipher.doFinal(...);    // conclusion of operation
 * 
 *      // Use a different IV value for every encryption
 *      byte[] newIv = ...;
 *      s = new GCMParameterSpec(s.getTLen(), newIv);
 *      cipher.init(..., s);
 *      ...
 * 
 *  
 *  Every implementation of the Java platform is required to support
 *  the following standard Cipher transformations with the keysizes
 *  in parentheses:
 *  
 *  AES/CBC/NoPadding (128)
 *  AES/CBC/PKCS5Padding (128)
 *  AES/ECB/NoPadding (128)
 *  AES/ECB/PKCS5Padding (128)
 *  DES/CBC/NoPadding (56)
 *  DES/CBC/PKCS5Padding (56)
 *  DES/ECB/NoPadding (56)
 *  DES/ECB/PKCS5Padding (56)
 *  DESede/CBC/NoPadding (168)
 *  DESede/CBC/PKCS5Padding (168)
 *  DESede/ECB/NoPadding (168)
 *  DESede/ECB/PKCS5Padding (168)
 *  RSA/ECB/PKCS1Padding (1024, 2048)
 *  RSA/ECB/OAEPWithSHA-1AndMGF1Padding (1024, 2048)
 *  RSA/ECB/OAEPWithSHA-256AndMGF1Padding (1024, 2048)
 *  
 *  These transformations are described in the
 *  
 *  Cipher section of the
 *  Java Cryptography Architecture Standard Algorithm Name Documentation.
 *  Consult the release documentation for your implementation to see if any
 *  other transformations are supported.
 */
class Cipher extends Object {

    /** Finishes a multiple-part encryption or decryption operation, depending
     *  on how this cipher was initialized.
     */
    @stub
    def doFinal(): Array[Byte] = ???

    /** Encrypts or decrypts data in a single-part operation, or finishes a
     *  multiple-part operation.
     */
    @stub
    def doFinal(input: Array[Byte]): Array[Byte] = ???

    /** Finishes a multiple-part encryption or decryption operation, depending
     *  on how this cipher was initialized.
     */
    @stub
    def doFinal(output: Array[Byte], outputOffset: Int): Int = ???

    /** Encrypts or decrypts data in a single-part operation, or finishes a
     *  multiple-part operation.
     */
    @stub
    def doFinal(input: Array[Byte], inputOffset: Int, inputLen: Int): Array[Byte] = ???

    /** Encrypts or decrypts data in a single-part operation, or finishes a
     *  multiple-part operation.
     */
    @stub
    def doFinal(input: Array[Byte], inputOffset: Int, inputLen: Int, output: Array[Byte]): Int = ???

    /** Encrypts or decrypts data in a single-part operation, or finishes a
     *  multiple-part operation.
     */
    @stub
    def doFinal(input: Array[Byte], inputOffset: Int, inputLen: Int, output: Array[Byte], outputOffset: Int): Int = ???

    /** Encrypts or decrypts data in a single-part operation, or finishes a
     *  multiple-part operation.
     */
    @stub
    def doFinal(input: ByteBuffer, output: ByteBuffer): Int = ???

    /** Returns the algorithm name of this Cipher object. */
    @stub
    def getAlgorithm(): String = ???

    /** Returns the block size (in bytes). */
    @stub
    def getBlockSize(): Int = ???

    /** Returns the exemption mechanism object used with this cipher. */
    @stub
    def getExemptionMechanism(): ExemptionMechanism = ???

    /** Returns the initialization vector (IV) in a new buffer. */
    @stub
    def getIV(): Array[Byte] = ???

    /** Returns the length in bytes that an output buffer would need to be in
     *  order to hold the result of the next update or
     *  doFinal operation, given the input length
     *  inputLen (in bytes).
     */
    @stub
    def getOutputSize(inputLen: Int): Int = ???

    /** Returns the parameters used with this cipher. */
    @stub
    def getParameters(): AlgorithmParameters = ???

    /** Returns the provider of this Cipher object. */
    @stub
    def getProvider(): Provider = ???

    /** Initializes this cipher with the public key from the given certificate. */
    @stub
    def init(opmode: Int, certificate: Certificate): Unit = ???

    /** Initializes this cipher with the public key from the given certificate
     *  and
     *  a source of randomness.
     */
    @stub
    def init(opmode: Int, certificate: Certificate, random: SecureRandom): Unit = ???

    /** Initializes this cipher with a key. */
    @stub
    def init(opmode: Int, key: Key): Unit = ???

    /** Initializes this cipher with a key and a set of algorithm
     *  parameters.
     */
    @stub
    def init(opmode: Int, key: Key, params: AlgorithmParameters): Unit = ???

    /** Initializes this cipher with a key and a set of algorithm
     *  parameters.
     */
    @stub
    def init(opmode: Int, key: Key, params: AlgorithmParameterSpec): Unit = ???

    /** Initializes this cipher with a key, a set of algorithm
     *  parameters, and a source of randomness.
     */
    @stub
    def init(opmode: Int, key: Key, params: AlgorithmParameterSpec, random: SecureRandom): Unit = ???

    /** Initializes this cipher with a key, a set of algorithm
     *  parameters, and a source of randomness.
     */
    @stub
    def init(opmode: Int, key: Key, params: AlgorithmParameters, random: SecureRandom): Unit = ???

    /** Initializes this cipher with a key and a source of randomness. */
    @stub
    def init(opmode: Int, key: Key, random: SecureRandom): Unit = ???

    /** Unwrap a previously wrapped key. */
    @stub
    def unwrap(wrappedKey: Array[Byte], wrappedKeyAlgorithm: String, wrappedKeyType: Int): Key = ???

    /** Continues a multiple-part encryption or decryption operation
     *  (depending on how this cipher was initialized), processing another data
     *  part.
     */
    @stub
    def update(input: Array[Byte]): Array[Byte] = ???

    /** Continues a multiple-part encryption or decryption operation
     *  (depending on how this cipher was initialized), processing another data
     *  part.
     */
    @stub
    def update(input: Array[Byte], inputOffset: Int, inputLen: Int): Array[Byte] = ???

    /** Continues a multiple-part encryption or decryption operation
     *  (depending on how this cipher was initialized), processing another data
     *  part.
     */
    @stub
    def update(input: Array[Byte], inputOffset: Int, inputLen: Int, output: Array[Byte]): Int = ???

    /** Continues a multiple-part encryption or decryption operation
     *  (depending on how this cipher was initialized), processing another data
     *  part.
     */
    @stub
    def update(input: Array[Byte], inputOffset: Int, inputLen: Int, output: Array[Byte], outputOffset: Int): Int = ???

    /** Continues a multiple-part encryption or decryption operation
     *  (depending on how this cipher was initialized), processing another data
     *  part.
     */
    @stub
    def update(input: ByteBuffer, output: ByteBuffer): Int = ???

    /** Continues a multi-part update of the Additional Authentication
     *  Data (AAD).
     */
    @stub
    def updateAAD(src: Array[Byte]): Unit = ???

    /** Continues a multi-part update of the Additional Authentication
     *  Data (AAD), using a subset of the provided buffer.
     */
    @stub
    def updateAAD(src: Array[Byte], offset: Int, len: Int): Unit = ???

    /** Continues a multi-part update of the Additional Authentication
     *  Data (AAD).
     */
    @stub
    def updateAAD(src: ByteBuffer): Unit = ???
}

object Cipher {
    /** Constant used to initialize cipher to decryption mode. */
    @stub
    val DECRYPT_MODE: Int = ???

    /** Constant used to initialize cipher to encryption mode. */
    @stub
    val ENCRYPT_MODE: Int = ???

    /** Constant used to indicate the to-be-unwrapped key is a "private key". */
    @stub
    val PRIVATE_KEY: Int = ???

    /** Constant used to indicate the to-be-unwrapped key is a "public key". */
    @stub
    val PUBLIC_KEY: Int = ???

    /** Constant used to indicate the to-be-unwrapped key is a "secret key". */
    @stub
    val SECRET_KEY: Int = ???

    /** Constant used to initialize cipher to key-unwrapping mode. */
    @stub
    val UNWRAP_MODE: Int = ???

    /** Returns a Cipher object that implements the specified
     *  transformation.
     */
    @stub
    def getInstance(transformation: String): Cipher = ???

    /** Returns a Cipher object that implements the specified
     *  transformation.
     */
    @stub
    def getInstance(transformation: String, provider: Provider): Cipher = ???

    /** Returns a Cipher object that implements the specified
     *  transformation.
     */
    @stub
    def getInstance(transformation: String, provider: String): Cipher = ???

    /** Returns the maximum key length for the specified transformation
     *  according to the installed JCE jurisdiction policy files.
     */
    @stub
    def getMaxAllowedKeyLength(transformation: String): Int = ???

    /** Returns an AlgorithmParameterSpec object which contains
     *  the maximum cipher parameter value according to the
     *  jurisdiction policy file.
     */
    @stub
    def getMaxAllowedParameterSpec(transformation: String): AlgorithmParameterSpec = ???
}
