package javax.xml.bind.annotation

import java.lang.{Class, String}
import java.lang.annotation.{ElementType, Retention, RetentionPolicy, Target}
import scala.annotation.StaticAnnotation
import scala.scalanative.annotation.stub

/** 
 *  Maps a JavaBean property to a XML element derived from property's type.
 *  
 *  Usage
 *  
 *  @XmlElementRef annotation can be used with a
 *  JavaBean property or from within XmlElementRefs
 *  
 *  This annotation dynamically associates an XML element name with the JavaBean
 *  property. When a JavaBean property is annotated with XmlElement, the XML element name is statically derived from the
 *  JavaBean property name. However, when this annotation is used, the
 *  XML element name is derived from the instance of the type of the
 *  JavaBean property at runtime.
 * 
 *   XML Schema substitution group support 
 *  XML Schema allows a XML document author to use XML element names
 *  that were not statically specified in the content model of a
 *  schema using substitution groups. Schema derived code provides
 *  support for substitution groups using an element property,
 *  (section 5.5.5, "Element Property" of JAXB 2.0 specification). An
 *  element property method signature is of the form:
 *  
 *      public void setTerm(JAXBElement);
 *      public JAXBElement getTerm();
 *  
 *  
 *  An element factory method annotated with  XmlElementDecl is
 *  used to create a JAXBElement instance, containing an XML
 *  element name. The presence of @XmlElementRef annotation on an
 *  element property indicates that the element name from JAXBElement
 *  instance be used instead of deriving an XML element name from the
 *  JavaBean property name.
 * 
 *  
 *  The usage is subject to the following constraints:
 *  
 *     If the collection item type (for collection property) or
 *         property type (for single valued property) is
 *         JAXBElement, then
 *         @XmlElementRef}.name() and @XmlElementRef.namespace() must
 *         point an element factory method  with an @XmlElementDecl
 *         annotation in a class annotated  with @XmlRegistry (usually
 *         ObjectFactory class generated by  the schema compiler) :
 *         
 *              @XmlElementDecl.name() must equal @XmlElementRef.name()  
 *              @XmlElementDecl.namespace() must equal @XmlElementRef.namespace(). 
 *         
 *    
 *     If the collection item type (for collection property) or
 *         property type  (for single valued property) is not
 *         JAXBElement, then the type referenced by the
 *         property or field must be annotated  with XmlRootElement. 
 *     This annotation can be used with the following annotations:
 *         XmlElementWrapper, XmlJavaTypeAdapter.
 *    
 * 
 *  See "Package Specification" in javax.xml.bind.package javadoc for
 *  additional common information.
 * 
 *  Example 1: Ant Task Example
 *  The following Java class hierarchy models an Ant build
 *  script.  An Ant task corresponds to a class in the class
 *  hierarchy. The XML element name of an Ant task is indicated by the
 *  @XmlRootElement annotation on its corresponding class.
 *  
 *      @XmlRootElement(name="target")
 *      class Target {
 *          // The presence of @XmlElementRef indicates that the XML
 *          // element name will be derived from the @XmlRootElement
 *          // annotation on the type (for e.g. "jar" for JarTask).
 *          @XmlElementRef
 *          List<Task> tasks;
 *      }
 * 
 *      abstract class Task {
 *      }
 * 
 *      @XmlRootElement(name="jar")
 *      class JarTask extends Task {
 *          ...
 *      }
 * 
 *      @XmlRootElement(name="javac")
 *      class JavacTask extends Task {
 *          ...
 *      }
 * 
 *      <!-- XML Schema fragment -->
 *      <xs:element name="target" type="Target">
 *      <xs:complexType name="Target">
 *        <xs:sequence>
 *          <xs:choice maxOccurs="unbounded">
 *            <xs:element ref="jar">
 *            <xs:element ref="javac">
 *          </xs:choice>
 *        </xs:sequence>
 *      </xs:complexType>
 * 
 *  
 *  
 *  Thus the following code fragment:
 *  
 *      Target target = new Target();
 *      target.tasks.add(new JarTask());
 *      target.tasks.add(new JavacTask());
 *      marshal(target);
 *  
 *  will produce the following XML output:
 *  
 *      <target>
 *        <jar>
 *          ....
 *        </jar>
 *        <javac>
 *          ....
 *        </javac>
 *      </target>
 *  
 *  
 *  It is not an error to have a class that extends Task
 *  that doesn't have XmlRootElement. But they can't show up in an
 *  XML instance (because they don't have XML element names).
 * 
 *  Example 2: XML Schema Susbstitution group support
 *   The following example shows the annotations for XML Schema
 *  substitution groups.  The annotations and the ObjectFactory are
 *  derived from the schema.
 * 
 *  
 *      @XmlElement
 *      class Math {
 *          //  The value of type()is
 *          //  JAXBElement.class , which indicates the XML
 *          //  element name ObjectFactory - in general a class marked
 *          //  with @XmlRegistry. (See ObjectFactory below)
 *          //
 *          //  The name() is "operator", a pointer to a
 *          // factory method annotated with a
 *          //  XmlElementDecl with the name "operator". Since
 *          //  "operator" is the head of a substitution group that
 *          //  contains elements "add" and "sub" elements, "operator"
 *          //  element can be substituted in an instance document by
 *          //  elements "add" or "sub". At runtime, JAXBElement
 *          //  instance contains the element name that has been
 *          //  substituted in the XML document.
 *          //
 *          @XmlElementRef(type=JAXBElement.class,name="operator")
 *          JAXBElement<? extends Operator> term;
 *      }
 * 
 *      @XmlRegistry
 *      class ObjectFactory {
 *          @XmlElementDecl(name="operator")
 *          JAXBElement<Operator> createOperator(Operator o) {...}
 *          @XmlElementDecl(name="add",substitutionHeadName="operator")
 *          JAXBElement<Operator> createAdd(Operator o) {...}
 *          @XmlElementDecl(name="sub",substitutionHeadName="operator")
 *          JAXBElement<Operator> createSub(Operator o) {...}
 *      }
 * 
 *      class Operator {
 *          ...
 *      }
 *  
 *  
 *  Thus, the following code fragment
 *  
 *      Math m = new Math();
 *      m.term = new ObjectFactory().createAdd(new Operator());
 *      marshal(m);
 *  
 *  will produce the following XML output:
 *  
 *      <math>
 *        <add>...</add>
 *      </math>
 *  
 */
@Retention(value=RUNTIME)
@Target(value={FIELD,METHOD})
final class XmlElementRef extends StaticAnnotation {

    /**  */
    @stub
    val name: String = ???

    /** This parameter and name() are used to determine the
     *  XML element for the JavaBean property.
     */
    @stub
    val namespace: String = ???

    /** Customize the element declaration to be required. */
    @stub
    val required: Boolean = ???

    /** The Java type being referenced. */
    @stub
    val type: Class = ???
}
